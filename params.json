{"name":"Luaj","tagline":"Lightweight, fast, Java-centric Lua interpreter written for JME and JSE, with string, table, package, math, io, os, debug, coroutine & luajava libraries, JSR-223 bindings, all metatags, weak tables and unique direct lua-to-java-bytecode compiling.","body":"![LuaJ](https://raw.githubusercontent.com/Tidal-Loop/LuaJ/master/icon.gif)\r\n#LuaJ\r\n* * *\r\n\r\n#Getting Started with LuaJ.\r\n\r\nJames Roseborough, Ian Farmer, Version 3.0\r\n\r\n<small>Copyright © 2009-2014 Luaj.org. (Also Nathan, Marcus, and Pratik for the crazy hack job with the chainsaw that makes it make it through proguard on Android without warnings.) Freely available under the terms of the [Luaj license](http://sourceforge.net/dbimage.php?id=196142).</small>\r\n\r\n* * *\r\n\r\n[introduction](#1) · [examples](#2) · [concepts](#3) · [libraries](#4) · [luaj api](#5) · [parser](#6) · [building](#7) · [downloads](#8) · [release notes](#9)\r\n\r\n# 1 - <a name=\"1\">Introduction</a>\r\n\r\n## Goals of Luaj\r\n\r\nLuaj is a lua interpreter based on the 5.2.x version of lua with the following goals in mind:\r\n\r\n*   Java-centric implementation of lua vm built to leverage standard Java features.\r\n*   Lightweight, high performance execution of lua.\r\n*   Multi-platform to be able to run on JME, JSE, or JEE environments.\r\n*   Complete set of libraries and tools for integration into real-world projects.\r\n*   Dependable due to sufficient unit testing of vm and library features.\r\n\r\n## Luaj version and Lua Versions\r\n\r\n### Luaj 3.0.x\r\n\r\nSupport for lua 5.2.x features:\r\n\r\n*   _ENV environments model.\r\n*   yield from pcall or metatags.\r\n*   Bitwise operator library.\r\n\r\nIt also includes miscellaneous improvements over luaj 2.0.x:\r\n\r\n*   Better thread safety.\r\n*   More compatible table behavior.\r\n*   Better coroutine-related garbage collection.\r\n*   Maven integration.\r\n*   Better debug reporting when using closures.\r\n*   Line numbers in parse syntax tree.\r\n\r\n### Luaj 2.0.x\r\n\r\nSupport for lua 5.1.x features, plus:\r\n\r\n*   Support for compiling lua source code into Java source code.\r\n*   Support for compiling lua bytecode directly into Java bytecode.\r\n*   Stackless vm design centered around dynamically typed objects.\r\n*   Good alignment with C API (see [names.csv](names.csv) for details)\r\n*   Implementation of weak keys and values, and all metatags.\r\n\r\n### Luaj 1.0.x\r\n\r\nSupport for most lua 5.1.x features.\r\n\r\n## Performance\r\n\r\nGood performance is a major goal of luaj. The following table provides measured execution times on a subset of benchmarks from [the computer language benchmarks game](http://shootout.alioth.debian.org/) in comparison with the standard C distribution.\r\n\r\n| Project  | Version | Mode             | Benchmark execution time (sec) |               |             |          | Language | Sample Command                                                  |\r\n|----------|---------|------------------|--------------------------------|---------------|-------------|----------|----------|-----------------------------------------------------------------|\r\n|          |         |                  | binarytrees (15)               | fannkuch (10) | nbody (1e6) | nsieve 9 |          |                                                                 |\r\n| luaj     | 3.0     | -b (luajc)       | 2.980                          | 5.073         | 16.794      | 11.274   | Java     | java -cp luaj-jse-3.0.1.jar;bcel-5.2.jar lua -b fannkuch.lua 10 |\r\n|          |         | -n (interpreted) | 12.838                         | 23.290        | 36.894      | 15.163   |          | java -cp luaj-jse-3.0.1.jar lua -n fannkuch.lua 10              |\r\n| lua      | 5.1.4   |                  | 17.637                         | 16.044        | 15.201      | 5.477    | C        | lua fannkuch.lua 10                                             |\r\n| jill     | 1.0.1   |                  | 44.512                         | 54.630        | 72.172      | 20.779   | Java     |                                                                 |\r\n| kahlua   | 1.0     | jse              | 22.963                         | 63.277        | 68.223      | 21.529   | Java     |                                                                 |\r\n| mochalua | 1.0     |                  | 50.457                         | 70.368        | 82.868      | 41.262   | Java     |                                                                 |\r\n\r\n\r\nLuaj in interpreted mode performs well for the benchmarks, and even better when the lua-to-java-bytecode (luajc) compiler is used, and actually executes _faster_ than C-based lua in some cases. It is also faster than Java-lua implementations Jill, Kahlua, and Mochalua for all benchmarks tested.\r\n\r\n# 2 - <a name=\"2\">Examples</a>\r\n\r\n## Run a lua script in Java SE\r\n\r\nFrom the main distribution directory line type:\r\n\r\n<pre>\tjava -cp lib/luaj-jse-3.0.jar lua examples/lua/hello.lua\r\n</pre>\r\n\r\nYou should see the following output:\r\n\r\n<pre>\thello, world\r\n</pre>\r\n\r\nTo see how luaj can be used to acccess most Java API's including swing, try:\r\n\r\n<pre>\tjava -cp lib/luaj-jse-3.0.jar lua examples/lua/swingapp.lua\r\n</pre>\r\n\r\nLinks to sources:\t[examples/lua/hello.lua](examples/lua/hello.lua) [examples/lua/swingapp.lua](examples/lua/swingapp.lua)\r\n\r\n## Compile lua source to lua bytecode\r\n\r\nFrom the main distribution directory line type:\r\n\r\n<pre>\tjava -cp lib/luaj-jse-3.0.jar luac examples/lua/hello.lua\r\n\tjava -cp lib/luaj-jse-3.0.jar lua luac.out\r\n</pre>\r\n\r\nThe compiled output \"luac.out\" is lua bytecode and should run and produce the same result.\r\n\r\n## Compile lua source or bytecode to java bytecode\r\n\r\nLuaj can compile lua sources or binaries directly to java bytecode if the bcel library is on the class path. From the main distribution directory line type:\r\n\r\n<pre>\tant bcel-lib\r\n\tjava -cp \"lib/luaj-jse-3.0.jar;lib/bcel-5.2.jar\" luajc -s examples/lua -d . hello.lua\r\n\tjava -cp \"lib/luaj-jse-3.0.jar;.\" lua -l hello\r\n</pre>\r\n\r\nThe output _hello.class_ is Java bytecode, should run and produce the same result. There is no runtime dependency on the bcel library, but the compiled classes must be in the class path at runtime, unless runtime jit-compiling via luajc and bcel are desired (see later sections).\r\n\r\nLua scripts can also be run directly in this mode without precompiling using the _lua_ command with the **_-b_** option and providing the _bcel_ library in the class path:\r\n\r\n<pre>\tjava -cp \"lib/luaj-jse-3.0.jar;lib/bcel-5.2.jar\" lua -b examples/lua/hello.lua\r\n</pre>\r\n\r\n## Run a script in a Java Application\r\n\r\nA simple hello, world example in luaj is:\r\n\r\n<pre>\timport org.luaj.vm2.*;\r\n\timport org.luaj.vm2.lib.jse.*;\r\n\r\n\tGlobals globals = JsePlatform.standardGlobals();\r\n\tLuaValue chunk = globals.load(\"print 'hello, world'\");\r\n\tchunk.call();\r\n\r\n</pre>\r\n\r\nLoading from a file is done via Globals.loadFile():\r\n\r\n<pre>\tLuaValue chunk = globals.loadfile(\"examples/lua/hello.lua\");\r\n</pre>\r\n\r\nChunks can also be loaded from a `Reader` as text source\r\n\r\n<pre>\tchunk = globals.load(new StringReader(\"print 'hello, world'\"), \"main.lua\");\r\n</pre>\r\n\r\nor an InputStream to be loaded as text source \"t\", or binary lua file \"b\":\r\n\r\n<pre>\tchunk = globals.load(new FileInputSStream(\"examples/lua/hello.lua\"), \"main.lua\", \"bt\"));\r\n</pre>\r\n\r\nA simple example may be found in [examples/jse/SampleJseMain.java](examples/jse/SampleJseMain.java)\r\n\r\n\r\nYou must include the library **lib/luaj-jse-3.0.jar** in your class path.\r\n\r\n## Run a script in a MIDlet\r\n\r\nFor MIDlets the _JmePlatform_ is used instead:\r\n\r\n<pre>\timport org.luaj.vm2.*;\r\n\timport org.luaj.vm2.lib.jme.*;\r\n\r\n\tGlobals globals = JmePlatform.standardGlobals();\r\n\tLuaValue chunk = globals.loadfile(\"examples/lua/hello.lua\");\r\n\tchunk.call();\r\n</pre>\r\n\r\nThe file must be a resource within within the midlet jar for the loader to find it. Any files included via _require()_ must also be part of the midlet resources.\r\n\r\nA simple example may be found in [examples/jme/SampleMIDlet.java](examples/jme/SampleMIDlet.java)\r\n\r\n\r\nYou must include the library **lib/luaj-jme-3.0.jar** in your midlet jar.\r\n\r\nAn ant script to build and run the midlet is in [build-midlet.xml](build-midlet.xml)\r\n\r\n\r\nYou must install the wireless toolkit and define _WTK_HOME_ for this script to work.\r\n\r\n## Run a script using JSR-223 Dynamic Scripting\r\n\r\nThe standard use of JSR-223 scripting engines may be used:\r\n\r\n<pre>\tScriptEngineManager mgr = new ScriptEngineManager();\r\n\tScriptEngine e = mgr.getEngineByName(\"luaj\");\r\n\te.put(\"x\", 25);\r\n\te.eval(\"y = math.sqrt(x)\");\r\n\tSystem.out.println( \"y=\"+e.get(\"y\") );\r\n</pre>\r\n\r\nYou can also look up the engine by language \"lua\" or mimetypes \"text/lua\" or \"application/lua\".\r\n\r\nAll standard aspects of script engines including compiled statements are supported.\r\n\r\nYou must include the library **lib/luaj-jse-3.0.jar** in your class path.\r\n\r\nA working example may be found in [examples/jse/ScriptEngineSample.java](examples/jse/ScriptEngineSample.java)\r\n\r\n\r\nTo compile and run it using Java 1.6 or higher:\r\n\r\n<pre>\tjavac -cp lib/luaj-jse-3.0.jar examples/jse/ScriptEngineSample.java\r\n\tjava -cp \"lib/luaj-jse-3.0.jar;examples/jse\" ScriptEngineSample\r\n</pre>\r\n\r\n## Excluding the lua bytecode compiler\r\n\r\nBy default, the compiler is included whenever _standardGlobals()_ or _debugGlobals()_ are called. Without a compiler, files can still be executed, but they must be compiled elsewhere beforehand. The \"luac\" utility is provided in the jse jar for this purpose, or a standard lua compiler can be used.\r\n\r\nTo exclude the lua-to-lua-bytecode compiler, do not call _standardGlobals()_ or _debugGlobals()_ but instead initialize globals with including only those libraries that are needed and omitting the line:\r\n\r\n<pre>\torg.luaj.vm2.compiler.LuaC.install(globals);\r\n</pre>\r\n\r\n## Including the LuaJC lua-bytecode-to-Java-bytecode compiler\r\n\r\nTo compile from lua to Java bytecode for all lua loaded at runtime, install the LuaJC compiler into a _globals_ object use:\r\n\r\n<pre>\torg.luaj.vm2.jse.luajc.LuaJC.install(globals);\r\n</pre>\r\n\r\nThis will compile all lua bytecode into Java bytecode, regardless of if they are loaded as lua source or lua binary files.\r\n\r\nThe requires _bcel_ to be on the class path, and the ClassLoader of JSE or CDC.\r\n\r\n# 3 - <a name=\"3\">Concepts</a>\r\n\r\n## Globals\r\n\r\nThe old notion of platform has been replaced with creation of globals. The [Globals](http://luaj.sourceforge.net/api/3.0/org/luaj/vm2/Globals.html) class holds global state needed for executing closures as well as providing convenience functions for compiling and loading scripts.\r\n\r\n## Platform\r\n\r\nTo simplify construction of Globals, and encapsulate differences needed to support the diverse family of Java runtimes, luaj uses a Platform notion. Typically, a platform is used to construct a Globals, which is then provided as a global environment for client scripts.\r\n\r\n### JsePlatform\r\n\r\nThe [JsePlatform](http://luaj.sourceforge.net/api/3.0/org/luaj/vm2/lib/jse/JsePlatform.html) class can be used as a factory for globals in a typical Java SE application. All standard libraries are included, as well as the luajava library. The default search path is the current directory, and the math operations include all those supported by Java SE.\r\n\r\n#### Android\r\n\r\nAndroid applications should use the JsePlatform, and can include the [Luajava](#luajava) library to simplify access to underlying Android APIs. A specialized Globals.finder should be provided to find scripts and data for loading. See [examples/android/src/android/LuajView](https://github.com/Tidal-Loop/LuaJ/blob/master/examples/android/src/android/LuajView.java) for an example that loads from the \"res\" Android project directory. The ant build script is [examples/android/build.xml](examples/android/build.xml).\r\n\r\n#### Applet\r\n\r\nApplets in browsers should use the JsePlatform. The permissions model in applets is highly restrictive, so a specialization of the [Luajava](#luajava) library must be used that uses default class loading. This is illustrated in the sample Applet [examples/jse/SampleApplet.java](examples/jse/SampleApplet.java), which can be built using [build-applet.xml](build-applet.xml).\r\n\r\n### JmePlatform\r\n\r\nThe [JmePlatform](http://luaj.sourceforge.net/api/3.0/org/luaj/vm2/lib/jme/JmePlatform.html) class can be used to set up the basic environment for a Java ME application. The default search path is limited to the jar resources, and the math operations are limited to those supported by Java ME. All libraries are included except luajava, and the os, io, and math libraries are limited to those functions that can be supported on that platform.\r\n\r\n#### MIDlet\r\n\r\nMIDlets require the JmePlatform. The JME platform has several limitations which carry over to luaj. In particular Globals.finder is overridden to load as resources, so scripts should be colocated with class files in the MIDlet jar file. [Luajava](#luajava) cannot be used. Camples code is in [examples/jme/SampleMIDlet.java](examples/jme/SampleMIDlet.java), which can be built using [build-midlet.xml](build-midlet.xml).\r\n\r\n## Thread Safety\r\n\r\nLuaj 3.0 can be run in multiple threads, with the following restrictions:\r\n\r\n*   Each thread created by client code must be given its own, distinct Globals instance\r\n*   Each thread must not be allowed to access Globals from other threads\r\n*   Metatables for Number, String, Thread, Function, Boolean, and and Nil are shared and therefore should not be mutated once lua code is running in any thread.\r\n\r\nFor an example of loading allocating per-thread Globals and invoking scripts in multiple threads see [examples/jse/SampleMultiThreaded.java](examples/jse/SampleMultiThreaded.java)\r\n\r\nAs an alternative, the JSR-223 scripting interface can be used, and should always provide a separate Globals instance per script engine instance by using a ThreadLocal internally.\r\n\r\n# 4 - <a name=\"4\">Libraries</a>\r\n\r\n## Standard Libraries\r\n\r\nLibraries are coded to closely match the behavior specified in See [standard lua documentation](http://www.lua.org/manual/5.1/) for details on the library API's\r\n\r\nThe following libraries are loaded by both _JsePlatform.standardGlobals()_ and _JmePlatform.standardGlobals()_:\r\n\r\n<pre>\tbase\r\n\tbit32\r\n\tcoroutine\r\n\tio\r\n\tmath\r\n\tos\r\n\tpackage\r\n\tstring\r\n\ttable\r\n</pre>\r\n\r\nThe _JsePlatform.standardGlobals()_ globals also include:\r\n\r\n<pre>\tluajava\r\n</pre>\r\n\r\nThe _JsePlatform.debugGlobals()_ and _JsePlatform.debugGlobals()_ functions produce globals that include:\r\n\r\n<pre>\tdebug\r\n</pre>\r\n\r\n### I/O Library\r\n\r\nThe implementation of the _io_ library differs by platform owing to platform limitations.\r\n\r\nThe _JmePlatform.standardGlobals()_ instantiated the io library _io_ in\r\n\r\n<pre>\tsrc/jme/org/luaj/vm2/lib/jme/JmeIoLib.java\r\n</pre>\r\n\r\nThe _JsePlatform.standardGlobals()_ includes support for random access and is in\r\n\r\n<pre>\tsrc/jse/org/luaj/vm2/lib/jse/JseIoLib.java\r\n</pre>\r\n\r\n### OS Library\r\n\r\nThe implementation of the _os_ library also differs per platform.\r\n\r\nThe basic _os_ library implementation us used by _JmePlatform_ and is in:\r\n\r\n<pre>\tsrc/core/org/luaj/lib/OsLib.java\r\n</pre>\r\n\r\nA richer version for use by _JsePlatform_ is :\r\n\r\n<pre>\tsrc/jse/org/luaj/vm2/lib/jse/JseOsLib.java\r\n</pre>\r\n\r\nTime is a represented as number of seconds since the epoch, and locales are not implemented.\r\n\r\n### Coroutine Library\r\n\r\nThe _coroutine_ library is implemented using one JavaThread per coroutine. This allows _coroutine.yield()_ can be called from anywhere, as with the yield-from-anywhere patch in C-based lua.\r\n\r\nLuaj uses WeakReferences and the OrphanedThread error to ensure that coroutines that are no longer referenced are properly garbage collected. For thread safety, OrphanedThread should not be caught by Java code. See [LuaThread](http://luaj.sourceforge.net/api/3.0/org/luaj/vm2/LuaThread.html) and [OrphanedThread](http://luaj.sourceforge.net/api/3.0/org/luaj/vm2/OrphanedThread.html) javadoc for details.\r\n\r\n### Debug Library\r\n\r\nThe _debug_ library is not included by default by _JmePlatform.standardGlobals()_ or _JsePlatform.standardGlobsls()_ . The functions _JmePlatform.debugGlobals()_ and _JsePlatform.debugGlobsls()_ create globals that contain the debug library in addition to the other standard libraries. To install dynamically from lua use java-class-based require::\r\n\r\n<pre>\trequire 'org.luaj.vm2.lib.DebugLib'\r\n</pre>\r\n\r\nThe _lua_ command line utility includes the _debug_ library by default.\r\n\r\n### <a name=\"luajava\">The Luajava Library</a>\r\n\r\nThe _JsePlatform.standardGlobals()_ includes the _luajava_ library, which simplifies binding to Java classes and methods. It is patterned after the original [luajava project](http://www.keplerproject.org/luajava/).\r\n\r\nThe following lua script will open a swing frame on Java SE:\r\n\r\n<pre>\tjframe = luajava.bindClass( \"javax.swing.JFrame\" )\r\n\tframe = luajava.newInstance( \"javax.swing.JFrame\", \"Texts\" );\r\n\tframe:setDefaultCloseOperation(jframe.EXIT_ON_CLOSE)\r\n\tframe:setSize(300,400)\r\n\tframe:setVisible(true)\r\n</pre>\r\n\r\nSee a longer sample in _examples/lua/swingapp.lua_ for details, including a simple animation loop, rendering graphics, mouse and key handling, and image loading. Or try running it using:\r\n\r\n<pre>\tjava -cp lib/luaj-jse-3.0.jar lua examples/lua/swingapp.lua\r\n</pre>\r\n\r\nThe Java ME platform does not include this library, and it cannot be made to work because of the lack of a reflection API in Java ME.\r\n\r\nThe _lua_ connand line tool includes _luajava_.\r\n\r\n# 5 - <a name=\"5\">LuaJ API</a>\r\n\r\n## API Javadoc\r\n\r\nThe javadoc for the main classes in the LuaJ API are on line at [docs/api](docs/api/index.html)\r\n\r\n\r\nYou can also build a local version from sources using\r\n\r\n<pre>\t ant doc\r\n</pre>\r\n\r\n## LuaValue and Varargs\r\n\r\nAll lua value manipulation is now organized around [LuaValue](docs/api/org/luaj/vm2/LuaValue.html) which exposes the majority of interfaces used for lua computation. [org.luaj.vm2.LuaValue](docs/api/org/luaj/vm2/LuaValue.html)\r\n\r\n\r\n### Common Functions\r\n\r\n_LuaValue_ exposes functions for each of the operations in LuaJ. Some commonly used functions and constants include:\r\n\r\n<pre>\tcall();               // invoke the function with no arguments\r\n\tcall(LuaValue arg1);  // call the function with 1 argument\r\n\tinvoke(Varargs arg);  // call the function with variable arguments, variable return values\r\n\tget(int index);       // get a table entry using an integer key\r\n\tget(LuaValue key);    // get a table entry using an arbitrary key, may be a LuaInteger\r\n\trawget(int index);    // raw get without metatable calls\r\n\tvalueOf(int i);       // return LuaValue corresponding to an integer\r\n\tvalueOf(String s);    // return LuaValue corresponding to a String\r\n\ttoint();              // return value as a Java int\r\n\ttojstring();          // return value as a Java String\r\n\tisnil();              // is the value nil\r\n\tNIL;                  // the value nil\r\n\tNONE;                 // a Varargs instance with no values\t \r\n</pre>\r\n\r\n## Varargs\r\n\r\nThe interface [Varargs](http://luaj.sourceforge.net/api/3.0/org/luaj/vm2/Varargs.html) provides an abstraction for both a variable argument list and multiple return values. For convenience, _LuaValue_ implements _Varargs_ so a single value can be supplied anywhere variable arguments are expected. [org.luaj.vm2.Varargs](http://luaj.sourceforge.net/api/3.0/org/luaj/vm2/Varargs.html)\r\n\r\n### Common Functions\r\n\r\n_Varargs_ exposes functions for accessing elements, and coercing them to specific types:\r\n\r\n<pre>\tnarg();                 // return number of arguments\r\n\targ1();                 // return the first argument\r\n\targ(int n);             // return the nth argument\r\n\tisnil(int n);           // true if the nth argument is nil\r\n\tchecktable(int n);      // return table or throw error\r\n\toptlong(int n,long d);  // return n if a long, d if no argument, or error if not a long\r\n</pre>\r\n\r\nSee the [Varargs](docs/api/org/luaj/vm2/Varargs.html) API for a complete list.\r\n\r\n## LibFunction\r\n\r\nThe simplest way to implement a function is to choose a base class based on the number of arguments to the function. LuaJ provides 5 base classes for this purpose, depending if the function has 0, 1, 2, 3 or variable arguments, and if it provide multiple return values. [org.luaj.vm2.lib.ZeroArgFunction](docs/api/org/luaj/vm2/lib/ZeroArgFunction.html), [org.luaj.vm2.lib.OneArgFunction](docs/api/org/luaj/vm2/lib/OneArgFunction.html), [org.luaj.vm2.lib.TwoArgFunction](docs/api/org/luaj/vm2/lib/TwoArgFunction.html), [org.luaj.vm2.lib.ThreeArgFunction](docs/api/org/luaj/vm2/lib/ThreeArgFunction.html), [org.luaj.vm2.lib.VarArgFunction](docs/api/org/luaj/vm2/lib/VarArgFunction.html)\r\n\r\n\r\nEach of these functions has an abstract method that must be implemented, and argument fixup is done automatically by the classes as each Java function is invoked.\r\n\r\nAn example of a function with no arguments but a useful return value might be:\r\n\r\n<pre>\tpubic class hostname extends ZeroArgFunction {\r\n\t\tpublic LuaValue call() {\r\n\t\t\treturn valueOf(java.net.InetAddress.getLocalHost().getHostName());\r\n\t\t}\r\n\t}\r\n</pre>\r\n\r\nThe value _env_ is the environment of the function, and is normally supplied by the instantiating object whenever default loading is used.\r\n\r\nCalling this function from lua could be done by:\r\n\r\n<pre>\r\n\tlocal hostname = require( 'hostname' )\r\n</pre>\r\n\r\nwhile calling this function from Java would look like:\r\n\r\n<pre>\r\n\tnew hostname().call();\r\n</pre>\r\n\r\nNote that in both the lua and Java case, extra arguments will be ignored, and the function will be called. Also, no virtual machine instance is necessary to call the function. To allow for arguments, or return multiple values, extend one of the other base classes.\r\n\r\n## Libraries of Java Functions\r\n\r\nWhen require() is called, it will first attempt to load the module as a Java class that implements LuaFunction. To succeed, the following requirements must be met:\r\n\r\n*   The class must be on the class path with name, _modname_.\r\n*   The class must have a public default constructor.\r\n*   The class must inherit from LuaFunction.\r\n\r\nIf luaj can find a class that meets these critera, it will instantiate it, cast it to _LuaFunction_ then call() the instance with two arguments: the _modname_ used in the call to require(), and the environment for that function. The Java may use these values however it wishes. A typical case is to create named functions in the environment that can be called from lua.\r\n\r\nA complete example of Java code for a simple toy library is in [examples/jse/hyperbolic.java](examples/jse/hyperbolic.java)\r\n\r\n<pre>import org.luaj.vm2.LuaValue;\r\nimport org.luaj.vm2.lib.*;\r\n\r\npublic class hyperbolic extends TwoArgFunction {\r\n\r\n\tpublic hyperbolic() {}\r\n\r\n\tpublic LuaValue call(LuaValue modname, LuaValue env) {\r\n\t\tLuaValue library = tableOf();\r\n\t\tlibrary.set( \"sinh\", new sinh() );\r\n\t\tlibrary.set( \"cosh\", new cosh() );\r\n\t\tenv.set( \"hyperbolic\", library );\r\n\t\treturn library;\r\n\t}\r\n\r\n\tstatic class sinh extends OneArgFunction {\r\n\t\tpublic LuaValue call(LuaValue x) {\r\n\t\t\treturn LuaValue.valueOf(Math.sinh(x.checkdouble()));\r\n\t\t}\r\n\t}\r\n\r\n\tstatic class cosh extends OneArgFunction {\r\n\t\tpublic LuaValue call(LuaValue x) {\r\n\t\t\treturn LuaValue.valueOf(Math.cosh(x.checkdouble()));\r\n\t\t}\r\n\t}\r\n}\r\n</pre>\r\n\r\nIn this case the call to require invokes the library itself to initialize it. The library implementation puts entries into a table, and stores this table in the environment.\r\n\r\nThe lua script used to load and test it is in [examples/lua/hyperbolicapp.lua](examples/lua/hyperbolicapp.lua)\r\n\r\n<pre>\trequire 'hyperbolic'\r\n\r\n\tprint('hyperbolic', hyperbolic)\r\n\tprint('hyperbolic.sinh', hyperbolic.sinh)\r\n\tprint('hyperbolic.cosh', hyperbolic.cosh)\r\n\r\n\tprint('sinh(0.5)', hyperbolic.sinh(0.5))\r\n\tprint('cosh(0.5)', hyperbolic.cosh(0.5))\r\n</pre>\r\n\r\nFor this example to work the code in _hyperbolic.java_ must be compiled and put on the class path.\r\n\r\n## Closures\r\n\r\nClosures still exist in this framework, but are optional, and are only used to implement lua bytecode execution, and is generally not directly manipulated by the user of luaj.\r\n\r\nSee the [org.luaj.vm2.LuaClosure](docs/api/org/luaj/vm2/org/luaj/vm2/LuaClosure.html) javadoc for details on using that class directly.\r\n\r\n# 6 - <a name=\"6\">Parser</a>\r\n\r\n## Javacc Grammar\r\n\r\nA Javacc grammar was developed to simplify the creation of Java-based parsers for the lua language. The grammar is specified for [javacc version 5.0](https://javacc.dev.java.net/) because that tool generates standalone parsers that do not require a separate runtime.\r\n\r\nA plain undecorated grammer that can be used for validation is available in [grammar/Lua51.jj](grammar/Lua51.jj) while a grammar that generates a typed parse tree is in [grammar/LuaParser.jj](grammar/LuaParser.jj)\r\n\r\n## Creating a Parse Tree from Lua Source\r\n\r\nThe default lu compiler does a single-pass compile of lua source to lua bytecode, so no explicit parse tree is produced.\r\n\r\nTo simplify the creation of abstract syntax trees from lua sources, the LuaParser class is generated as part of the JME build. To use it, provide an input stream, and invoke the root generator, which will return a Chunk if the file is valid, or throw a ParseException if there is a syntax error.\r\n\r\nFor example, to parse a file and print all variable names, use code like:\r\n\r\n<pre>\ttry {\r\n\t\tString file = \"main.lua\";\r\n\t\tLuaParser parser = new LuaParser(new FileInputStream(file));\r\n\t\tChunk chunk = parser.Chunk();\r\n\t\tchunk.accept( new Visitor() {\r\n\t\t\tpublic void visit(Exp.NameExp exp) {\r\n\t\t\t\tSystem.out.println(\"Name in use: \"+exp.name.name\r\n\t\t\t\t\t+\" line \"+exp.beginLine\r\n\t\t\t\t\t+\" col \"+exp.beginColumn);\r\n\t\t\t}\r\n\t\t} );\r\n\t} catch ( ParseException e ) {\r\n\t\tSystem.out.println(\"parse failed: \" + e.getMessage() + \"\\n\"\r\n\t\t\t+ \"Token Image: '\" + e.currentToken.image + \"'\\n\"\r\n\t\t\t+ \"Location: \" + e.currentToken.beginLine + \":\" + e.currentToken.beginColumn\r\n\t\t\t         + \"-\" + e.currentToken.endLine + \",\" + e.currentToken.endColumn);\r\n\t}\r\n</pre>\r\n\r\nAn example that prints locations of all function definitions in a file may be found in [examples/jse/SampleParser.java](examples/jse/SampleParser.java)\r\n\r\n\r\nSee the [org.luaj.vm2.ast package](docs/api/org/luaj/vm2/ast/package-summary.html) javadoc for the API relating to the syntax tree that is produced.\r\n\r\n# 7 - <a name=\"7\">Building and Testing</a>\r\n\r\n## <a name=\"maven\">Maven integration</a>\r\n\r\nThe main jar files are now deployed in the maven central repository. To use them in your maven-based project, list them as a dependency:\r\n\r\nFor JSE projects, add this dependency for the luaj-jse jar:\r\n\r\n<pre>   <dependency>\r\n      <groupId>org.luaj</groupId>\r\n      <artifactId>luaj-jse</artifactId>\r\n      <version>3.0</version>\r\n   </dependency>\r\n</pre>\r\n\r\nwhile for JME projects, use the luaj-jme jar:\r\n\r\n<pre>   <dependency>\r\n      <groupId>org.luaj</groupId>\r\n      <artifactId>luaj-jme</artifactId>\r\n      <version>3.0</version>\r\n   </dependency>\r\n</pre>\r\n\r\nAn example skelton maven pom file for a skeleton project is in [examples/maven/pom.xml](examples/maven/pom.xml)\r\n\r\n## Building the jars\r\n\r\nAn ant file is included in the root directory which builds the libraries by default.\r\n\r\nOther targets exist for creating distribution file an measuring code coverage of unit tests.\r\n\r\n## Unit tests\r\n\r\nThe main luaj JUnit tests are organized into a JUnit 3 suite:\r\n\r\n<pre>\ttest/junit/org/luaj/vm2/AllTests.lua\r\n</pre>\r\n\r\nUnit test scripts can be found in these locations\r\n\r\n<pre>\ttest/lua/*.lua\r\n\ttest/lua/errors/*.lua\r\n\ttest/lua/perf/*.lua\r\n\ttest/lua/luaj3.0-tests.zip\r\n</pre>\r\n\r\n## Code coverage\r\n\r\nA build script for running unit tests and producing code coverage statistics is in [build-coverage.xml](build-coverage.xml)\r\n\r\n\r\nIt relies on the cobertura code coverage library.\r\n\r\n# 8 - <a name=\"8\">Downloads</a>\r\n\r\n## Downloads and Project Pages\r\n\r\nDownloads for all version available on SourceForge or LuaForge. Sources are hosted on SourceForge and available via sourceforge.net [SourceForge Luaj Project Page](http://luaj.sourceforge.net/), [SourceForge Luaj Download Area](http://sourceforge.net/project/platformdownload.php?group_id=197627)\r\n\r\n\r\nThe jar files may also be downloaded from the maven central repository, see [Maven Integration](#maven).\r\n\r\nFiles are no longer hosted at LuaForge.\r\n\r\n# 9 - <a name=\"9\">Release Notes</a>\r\n\r\n## Main Changes by Version\r\n\r\n\r\n\r\n   **2.0** \r\n\r\n*   Initial release of 2.0 version\r\n\r\n \r\n  **2.0.1** \r\n\r\n*   Improve correctness of singleton construction related to static initialization\r\n*   Fix nan-related error in constant folding logic that was failing on some JVMs\r\n*   JSR-223 fixes: add META-INF/services entry in jse jar, improve bindings implementation\r\n\r\n \r\n   **2.0.2** \r\n\r\n*   JSR-223 bindings change: non Java-primitives will now be passed as LuaValue\r\n*   JSR-223 enhancement: allow both \".lua\" and \"lua\" as extensions in getScriptEngine()\r\n*   JSR-223 fix: use system class loader to support using luaj as JRE extension\r\n*   Improve selection logic when binding to overloaded functions using luajava\r\n*   Enhance javadoc, put it [in distribution](docs/api/index.html) and [on line](http://luaj.sourceforge.net/api/3.0/index.html)\r\n*   Major refactor of luajava type coercion logic, improve method selection.\r\n*   Add lib/luaj-sources-2.0.2.jar for easier integration into an IDE such as Netbeans\r\n\r\n \r\n   **2.0.3** \r\n\r\n*   Improve coroutine state logic including let unreferenced coroutines be garbage collected\r\n*   Fix lua command vararg values passed into main script to match what is in global arg table\r\n*   Add arithmetic metatag processing when left hand side is a number and right hand side has metatable\r\n*   Fix load(func) when mutiple string fragments are supplied by calls to func\r\n*   Allow access to public members of private inner classes where possible\r\n*   Turn on error reporting in LuaParser so line numbers ar available in ParseException\r\n*   Improve compatibility of table.remove()\r\n*   Disallow base library setfenv() calls on Java functions\r\n\r\n \r\n   **3.0-alpha1** \r\n\r\n*   Convert internal and external API's to match lua 5.2.x environment changes\r\n*   Add bit32 library\r\n*   Add explicit Globals object to manage global state, especially to imrpove thread safety\r\n*   Drop support for lua source to java surce (lua2java) in favor of direct java bytecode output (luajc)\r\n*   Remove compatibility functions like table.getn(), table.maxn(), table.foreach(), and math.log10()\r\n*   Add ability to create runnable jar file from lua script with sample build file build-app.xml\r\n\r\n \r\n  **3.0-alpha2** \r\n\r\n*   Supply environment as second argument to LibFunction when loading via require()\r\n\r\n \r\n   **3.0-alpha3** \r\n\r\n*   Fix bug 3597515 memory leak due to string caching by simplifying caching logic.\r\n*   Fix bug 3565008 so that short substrings are backed by short arrays.\r\n*   Fix bug 3495802 to return correct offset of substrings from string.find().\r\n*   Add artifacts to Maven central repository.\r\n*   Limit pluggable scripting to use compatible bindings and contexts, implement redirection.\r\n\r\n \r\n   **3.0-beta1** \r\n\r\n*   Fix bug that didn't read package.path from environment.\r\n*   Fix pluggable scripting engine lookup, simplify implementation, and add unit tests.\r\n*   Coerce script engine eval() return values to Java.\r\n*   Fix Lua to Java coercion directly on Java classes.\r\n*   Fix Globals.load() to call the library with an empty modname and the globals as the environment.\r\n*   Fix hash codes of double.\r\n*   Fix bug in luajava overload resolution.\r\n*   Fix luastring bug where parsing did not check for overflow.\r\n*   Fix luastring bug where circular dependency randomly caused NullPointerException.\r\n*   Major refactor of table implementation.\r\n*   Improved behavior of next() (fixes issue #7).\r\n*   Existing tables can now be made weak (fixes issue #16).\r\n*   More compatible allocation of table entries in array vs. hash (fixes issue #8).\r\n\r\n \r\n   **3.0-beta2** \r\n\r\n*   Fix os.time() to return a number of seconds instead of milliseconds.\r\n*   Implement formatting with os.date(), and table argument for os.time().\r\n*   LuaValue.checkfunction() now returns LuaFunction.\r\n*   Refactor APIs related to compiling and loading scripts to provide methods on Globals.\r\n*   Add API to compile from Readers as well as InputStreams.\r\n*   Add optional -c encoding flag to lua, luac, and luajc tools to control source encoding.\r\n*   Let errors thrown in debug hooks bubble up to the running coroutine.\r\n*   Make error message handler function in xpcall per-thread instead of per-globals.\r\n*   Establish \"org.luaj.debug\" and \"org.luaj.luajc\" system properties to configure scripting engine.\r\n\r\n \r\n   **3.0** \r\n\r\n*   Fix maven sample code.\r\n*   Add sample code for Android Application that uses luaj.\r\n*   Add sample code for Applet that uses luaj.\r\n*   Fix balanced match for empty string (fixes issue #23).\r\n*   Pass user-supplied ScriptContext to script engine evaluation (fixes issue #21).\r\n*   Autoflush and encode written bytes in script contexts (fixes issue #20).\r\n*   Rename Globals.FINDER to Globals.finder.\r\n*   Fix bug in Globals.UTF8Stream affecting loading from Readers.\r\n*   Add buffered input for compiling and loading of scripts.\r\n*   In CoerceJavaToLua.coerse(), coerce byte[] to LuaString (fixes issue #31).\r\n*   In CoerceJavaToLua.coerse(), coerce LuaValue to same value (fixes issue #29).\r\n*   Fix line number reporting in debug stack traces (fixes issue #30).\r\n\r\n\r\n\r\n## Known Issues\r\n\r\n### Limitations\r\n\r\n*   debug code may not be completely removed by some obfuscators\r\n*   tail calls are not tracked in debug information\r\n*   mixing different versions of luaj in the same java vm is not supported\r\n*   values associated with weak keys may linger longer than expected\r\n*   behavior of luaj when a SecurityManager is used has not been fully characterized\r\n*   negative zero is treated as identical to integer value zero throughout luaj\r\n*   lua compiled into java bytecode using luajc cannot use string.dump() or xpcall()\r\n*   number formatting with string.format() is not supported\r\n\r\n### File Character Encoding\r\n\r\nSource files can be considered encoded in UTF-8 or ISO-8859-1 and results should be as expected, with literal string contianing quoted characters compiling to the same byte sequences as the input. For a non ASCII-compatible encoding such as EBSDIC, however, there are restrictions:\r\n\r\n*   supplying a Reader to Globals.load() is preferred over InputStream variants\r\n*   using FileReader or InputStreamReader to get the default OS encoding should work in most cases\r\n*   string literals with quoted characters may not produce the expected values in generated code\r\n*   command-line tools lua, luac, and luajc will require _-c Cp037_ to specify the encoding\r\n\r\nThese restrictions are mainly a side effect of how the language is defined as allowing byte literals within literal strings in source files. Code that is generated on the fly within lua and compiled with lua's _load()_ function should work as expected, since these strings will never be represented with the host's native character encoding.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}